{"version":3,"sources":["../node_modules/scrollmagic/scrollmagic/uncompressed/plugins/debug.addIndicators.js"],"names":["ScrollMagic","NAMESPACE","console","window","err","Function","prototype","bind","call","error","log","_util","_autoindex","Scene","extend","_indicator","this","addIndicators","options","DEFAULT_OPTIONS","name","indent","parent","undefined","colorStart","colorEnd","colorTrigger","Indicator","on","add","remove","removeIndicators","controller","off","Controller","addOption","_info","info","_container","container","_isDocument","isDocument","_vertical","vertical","_indicators","groups","_log","Array","splice","arguments","apply","handleBoundsPositionChange","updateBoundsPositions","handleTriggerPositionChange","updateTriggerGroupPositions","addEventListener","specificIndicator","b","triggerSize","group","triggerGroup","members","g","length","css","paramPos","paramDimension","edge","get","scrollLeft","width","scrollTop","height","element","firstChild","bounds","specificGroup","elem","pos","transform","i","document","body","containerOffset","top","left","offset","paramTransform","triggerHook","-ms-transform","-webkit-transform","updateTriggerGroupLabel","text","textContent","addScene","newScene","_options","$super","destroy","removeEventListener","_ctrl","_elemBounds","TPL","_elemStart","start","_elemEnd","end","_boundsContainer","elements","appendChild","position","handleTriggerParamsChange","handleBoundsParamsChange","updateTriggerGroup","updateBounds","setTimeout","indexOf","removeTriggerGroup","removeBounds","e","what","parentNode","removeChild","v","border-bottom-width","border-right-width","bottom","right","padding","border-top-width","border-left-width","addBounds","triggerPosition","duration","display","Math","abs","push","triggerElem","trigger","newGroup","addTriggerGroup","color","inner","createElement","overflow","border-width","border-style","border-color","white-space","pointer-events","font-size","style","zIndex","w","factory","__webpack_require__"],"mappings":"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","file":"static/js/4.c2a7ac52.chunk.js","sourcesContent":["/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n/*!\n * ScrollMagic v2.0.6 (2018-10-08)\n * The javascript library for magical scroll interactions.\n * (c) 2018 Jan Paepke (@janpaepke)\n * Project Website: http://scrollmagic.io\n * \n * @version 2.0.6\n * @license Dual licensed under MIT license and GPL.\n * @author Jan Paepke - e-mail@janpaepke.de\n *\n * @file Debug Extension for ScrollMagic.\n */\n\n/**\n * This plugin was formerly known as the ScrollMagic debug extension.\n *\n * It enables you to add visual indicators to your page, to be able to see exactly when a scene is triggered.\n *\n * To have access to this extension, please include `plugins/debug.addIndicators.js`.\n * @mixin debug.addIndicators\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['ScrollMagic'], factory);\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    factory(require('scrollmagic'));\n  } else {\n    // no browser global export needed, just execute\n    factory(root.ScrollMagic || root.jQuery && root.jQuery.ScrollMagic);\n  }\n})(this, function (ScrollMagic) {\n  \"use strict\";\n\n  var NAMESPACE = \"debug.addIndicators\";\n  var console = window.console || {},\n      err = Function.prototype.bind.call(console.error || console.log || function () {}, console);\n\n  if (!ScrollMagic) {\n    err(\"(\" + NAMESPACE + \") -> ERROR: The ScrollMagic main module could not be found. Please make sure it's loaded before this plugin or use an asynchronous loader like requirejs.\");\n  } // plugin settings\n\n\n  var FONT_SIZE = \"0.85em\",\n      ZINDEX = \"9999\",\n      EDGE_OFFSET = 15; // minimum edge distance, added to indentation\n  // overall vars\n\n  var _util = ScrollMagic._util,\n      _autoindex = 0;\n  ScrollMagic.Scene.extend(function () {\n    var Scene = this,\n        _indicator;\n\n    var log = function log() {\n      if (Scene._log) {\n        // not available, when main source minified\n        Array.prototype.splice.call(arguments, 1, 0, \"(\" + NAMESPACE + \")\", \"->\");\n\n        Scene._log.apply(this, arguments);\n      }\n    };\n    /**\n     * Add visual indicators for a ScrollMagic.Scene.  \n     * @memberof! debug.addIndicators#\n     *\n     * @example\n     * // add basic indicators\n     * scene.addIndicators()\n     *\n     * // passing options\n     * scene.addIndicators({name: \"pin scene\", colorEnd: \"#FFFFFF\"});\n     *\n     * @param {object} [options] - An object containing one or more options for the indicators.\n     * @param {(string|object)} [options.parent=undefined] - A selector, DOM Object or a jQuery object that the indicators should be added to.  \n     If undefined, the controller's container will be used.\n     * @param {number} [options.name=\"\"] - This string will be displayed at the start and end indicators of the scene for identification purposes. If no name is supplied an automatic index will be used.\n     * @param {number} [options.indent=0] - Additional position offset for the indicators (useful, when having multiple scenes starting at the same position).\n     * @param {string} [options.colorStart=green] - CSS color definition for the start indicator.\n     * @param {string} [options.colorEnd=red] - CSS color definition for the end indicator.\n     * @param {string} [options.colorTrigger=blue] - CSS color definition for the trigger indicator.\n     */\n\n\n    Scene.addIndicators = function (options) {\n      if (!_indicator) {\n        var DEFAULT_OPTIONS = {\n          name: \"\",\n          indent: 0,\n          parent: undefined,\n          colorStart: \"green\",\n          colorEnd: \"red\",\n          colorTrigger: \"blue\"\n        };\n        options = _util.extend({}, DEFAULT_OPTIONS, options);\n        _autoindex++;\n        _indicator = new Indicator(Scene, options);\n        Scene.on(\"add.plugin_addIndicators\", _indicator.add);\n        Scene.on(\"remove.plugin_addIndicators\", _indicator.remove);\n        Scene.on(\"destroy.plugin_addIndicators\", Scene.removeIndicators); // it the scene already has a controller we can start right away.\n\n        if (Scene.controller()) {\n          _indicator.add();\n        }\n      }\n\n      return Scene;\n    };\n    /**\n     * Removes visual indicators from a ScrollMagic.Scene.\n     * @memberof! debug.addIndicators#\n     *\n     * @example\n     * // remove previously added indicators\n     * scene.removeIndicators()\n     *\n     */\n\n\n    Scene.removeIndicators = function () {\n      if (_indicator) {\n        _indicator.remove();\n\n        this.off(\"*.plugin_addIndicators\");\n        _indicator = undefined;\n      }\n\n      return Scene;\n    };\n  });\n  /*\n  \t * ----------------------------------------------------------------\n  \t * Extension for controller to store and update related indicators\n  \t * ----------------------------------------------------------------\n  \t */\n  // add option to globally auto-add indicators to scenes\n\n  /**\n   * Every ScrollMagic.Controller instance now accepts an additional option.  \n   * See {@link ScrollMagic.Controller} for a complete list of the standard options.\n   * @memberof! debug.addIndicators#\n   * @method new ScrollMagic.Controller(options)\n   * @example\n   * // make a controller and add indicators to all scenes attached\n   * var controller = new ScrollMagic.Controller({addIndicators: true});\n   * // this scene will automatically have indicators added to it\n   * new ScrollMagic.Scene()\n   *                .addTo(controller);\n   *\n   * @param {object} [options] - Options for the Controller.\n   * @param {boolean} [options.addIndicators=false] - If set to `true` every scene that is added to the controller will automatically get indicators added to it.\n   */\n\n  ScrollMagic.Controller.addOption(\"addIndicators\", false); // extend Controller\n\n  ScrollMagic.Controller.extend(function () {\n    var Controller = this,\n        _info = Controller.info(),\n        _container = _info.container,\n        _isDocument = _info.isDocument,\n        _vertical = _info.vertical,\n        _indicators = {\n      // container for all indicators and methods\n      groups: []\n    };\n\n    var log = function log() {\n      if (Controller._log) {\n        // not available, when main source minified\n        Array.prototype.splice.call(arguments, 1, 0, \"(\" + NAMESPACE + \")\", \"->\");\n\n        Controller._log.apply(this, arguments);\n      }\n    };\n\n    if (Controller._indicators) {\n      log(2, \"WARNING: Scene already has a property '_indicators', which will be overwritten by plugin.\");\n    } // add indicators container\n\n\n    this._indicators = _indicators;\n    /*\n    \t\t\tneeded updates:\n    \t\t\t+++++++++++++++\n    \t\t\tstart/end position on scene shift (handled in Indicator class)\n    \t\t\ttrigger parameters on triggerHook value change (handled in Indicator class)\n    \t\t\tbounds position on container scroll or resize (to keep alignment to bottom/right)\n    \t\t\ttrigger position on container resize, window resize (if container isn't document) and window scroll (if container isn't document)\n    \t\t*/\n    // event handler for when associated bounds markers need to be repositioned\n\n    var handleBoundsPositionChange = function handleBoundsPositionChange() {\n      _indicators.updateBoundsPositions();\n    }; // event handler for when associated trigger groups need to be repositioned\n\n\n    var handleTriggerPositionChange = function handleTriggerPositionChange() {\n      _indicators.updateTriggerGroupPositions();\n    };\n\n    _container.addEventListener(\"resize\", handleTriggerPositionChange);\n\n    if (!_isDocument) {\n      window.addEventListener(\"resize\", handleTriggerPositionChange);\n      window.addEventListener(\"scroll\", handleTriggerPositionChange);\n    } // update all related bounds containers\n\n\n    _container.addEventListener(\"resize\", handleBoundsPositionChange);\n\n    _container.addEventListener(\"scroll\", handleBoundsPositionChange); // updates the position of the bounds container to aligned to the right for vertical containers and to the bottom for horizontal\n\n\n    this._indicators.updateBoundsPositions = function (specificIndicator) {\n      var // constant for all bounds\n      groups = specificIndicator ? [_util.extend({}, specificIndicator.triggerGroup, {\n        members: [specificIndicator]\n      })] : // create a group with only one element\n      _indicators.groups,\n          // use all\n      g = groups.length,\n          css = {},\n          paramPos = _vertical ? \"left\" : \"top\",\n          paramDimension = _vertical ? \"width\" : \"height\",\n          edge = _vertical ? _util.get.scrollLeft(_container) + _util.get.width(_container) - EDGE_OFFSET : _util.get.scrollTop(_container) + _util.get.height(_container) - EDGE_OFFSET,\n          b,\n          triggerSize,\n          group;\n\n      while (g--) {\n        // group loop\n        group = groups[g];\n        b = group.members.length;\n        triggerSize = _util.get[paramDimension](group.element.firstChild);\n\n        while (b--) {\n          // indicators loop\n          css[paramPos] = edge - triggerSize;\n\n          _util.css(group.members[b].bounds, css);\n        }\n      }\n    }; // updates the positions of all trigger groups attached to a controller or a specific one, if provided\n\n\n    this._indicators.updateTriggerGroupPositions = function (specificGroup) {\n      var // constant vars\n      groups = specificGroup ? [specificGroup] : _indicators.groups,\n          i = groups.length,\n          container = _isDocument ? document.body : _container,\n          containerOffset = _isDocument ? {\n        top: 0,\n        left: 0\n      } : _util.get.offset(container, true),\n          edge = _vertical ? _util.get.width(_container) - EDGE_OFFSET : _util.get.height(_container) - EDGE_OFFSET,\n          paramDimension = _vertical ? \"width\" : \"height\",\n          paramTransform = _vertical ? \"Y\" : \"X\";\n      var // changing vars\n      group, elem, pos, elemSize, transform;\n\n      while (i--) {\n        group = groups[i];\n        elem = group.element;\n        pos = group.triggerHook * Controller.info(\"size\");\n        elemSize = _util.get[paramDimension](elem.firstChild.firstChild);\n        transform = pos > elemSize ? \"translate\" + paramTransform + \"(-100%)\" : \"\";\n\n        _util.css(elem, {\n          top: containerOffset.top + (_vertical ? pos : edge - group.members[0].options.indent),\n          left: containerOffset.left + (_vertical ? edge - group.members[0].options.indent : pos)\n        });\n\n        _util.css(elem.firstChild.firstChild, {\n          \"-ms-transform\": transform,\n          \"-webkit-transform\": transform,\n          \"transform\": transform\n        });\n      }\n    }; // updates the label for the group to contain the name, if it only has one member\n\n\n    this._indicators.updateTriggerGroupLabel = function (group) {\n      var text = \"trigger\" + (group.members.length > 1 ? \"\" : \" \" + group.members[0].options.name),\n          elem = group.element.firstChild.firstChild,\n          doUpdate = elem.textContent !== text;\n\n      if (doUpdate) {\n        elem.textContent = text;\n\n        if (_vertical) {\n          // bounds position is dependent on text length, so update\n          _indicators.updateBoundsPositions();\n        }\n      }\n    }; // add indicators if global option is set\n\n\n    this.addScene = function (newScene) {\n      if (this._options.addIndicators && newScene instanceof ScrollMagic.Scene && newScene.controller() === Controller) {\n        newScene.addIndicators();\n      } // call original destroy method\n\n\n      this.$super.addScene.apply(this, arguments);\n    }; // remove all previously set listeners on destroy\n\n\n    this.destroy = function () {\n      _container.removeEventListener(\"resize\", handleTriggerPositionChange);\n\n      if (!_isDocument) {\n        window.removeEventListener(\"resize\", handleTriggerPositionChange);\n        window.removeEventListener(\"scroll\", handleTriggerPositionChange);\n      }\n\n      _container.removeEventListener(\"resize\", handleBoundsPositionChange);\n\n      _container.removeEventListener(\"scroll\", handleBoundsPositionChange); // call original destroy method\n\n\n      this.$super.destroy.apply(this, arguments);\n    };\n\n    return Controller;\n  });\n  /*\n  \t * ----------------------------------------------------------------\n  \t * Internal class for the construction of Indicators\n  \t * ----------------------------------------------------------------\n  \t */\n\n  var Indicator = function Indicator(Scene, options) {\n    var Indicator = this,\n        _elemBounds = TPL.bounds(),\n        _elemStart = TPL.start(options.colorStart),\n        _elemEnd = TPL.end(options.colorEnd),\n        _boundsContainer = options.parent && _util.get.elements(options.parent)[0],\n        _vertical,\n        _ctrl;\n\n    var log = function log() {\n      if (Scene._log) {\n        // not available, when main source minified\n        Array.prototype.splice.call(arguments, 1, 0, \"(\" + NAMESPACE + \")\", \"->\");\n\n        Scene._log.apply(this, arguments);\n      }\n    };\n\n    options.name = options.name || _autoindex; // prepare bounds elements\n\n    _elemStart.firstChild.textContent += \" \" + options.name;\n    _elemEnd.textContent += \" \" + options.name;\n\n    _elemBounds.appendChild(_elemStart);\n\n    _elemBounds.appendChild(_elemEnd); // set public variables\n\n\n    Indicator.options = options;\n    Indicator.bounds = _elemBounds; // will be set later\n\n    Indicator.triggerGroup = undefined; // add indicators to DOM\n\n    this.add = function () {\n      _ctrl = Scene.controller();\n      _vertical = _ctrl.info(\"vertical\");\n\n      var isDocument = _ctrl.info(\"isDocument\");\n\n      if (!_boundsContainer) {\n        // no parent supplied or doesnt exist\n        _boundsContainer = isDocument ? document.body : _ctrl.info(\"container\"); // check if window/document (then use body)\n      }\n\n      if (!isDocument && _util.css(_boundsContainer, \"position\") === 'static') {\n        // position mode needed for correct positioning of indicators\n        _util.css(_boundsContainer, {\n          position: \"relative\"\n        });\n      } // add listeners for updates\n\n\n      Scene.on(\"change.plugin_addIndicators\", handleTriggerParamsChange);\n      Scene.on(\"shift.plugin_addIndicators\", handleBoundsParamsChange); // updates trigger & bounds (will add elements if needed)\n\n      updateTriggerGroup();\n      updateBounds();\n      setTimeout(function () {\n        // do after all execution is finished otherwise sometimes size calculations are off\n        _ctrl._indicators.updateBoundsPositions(Indicator);\n      }, 0);\n      log(3, \"added indicators\");\n    }; // remove indicators from DOM\n\n\n    this.remove = function () {\n      if (Indicator.triggerGroup) {\n        // if not set there's nothing to remove\n        Scene.off(\"change.plugin_addIndicators\", handleTriggerParamsChange);\n        Scene.off(\"shift.plugin_addIndicators\", handleBoundsParamsChange);\n\n        if (Indicator.triggerGroup.members.length > 1) {\n          // just remove from memberlist of old group\n          var group = Indicator.triggerGroup;\n          group.members.splice(group.members.indexOf(Indicator), 1);\n\n          _ctrl._indicators.updateTriggerGroupLabel(group);\n\n          _ctrl._indicators.updateTriggerGroupPositions(group);\n\n          Indicator.triggerGroup = undefined;\n        } else {\n          // remove complete group\n          removeTriggerGroup();\n        }\n\n        removeBounds();\n        log(3, \"removed indicators\");\n      }\n    };\n    /*\n    \t\t * ----------------------------------------------------------------\n    \t\t * internal Event Handlers\n    \t\t * ----------------------------------------------------------------\n    \t\t */\n    // event handler for when bounds params change\n\n\n    var handleBoundsParamsChange = function handleBoundsParamsChange() {\n      updateBounds();\n    }; // event handler for when trigger params change\n\n\n    var handleTriggerParamsChange = function handleTriggerParamsChange(e) {\n      if (e.what === \"triggerHook\") {\n        updateTriggerGroup();\n      }\n    };\n    /*\n    \t\t * ----------------------------------------------------------------\n    \t\t * Bounds (start / stop) management\n    \t\t * ----------------------------------------------------------------\n    \t\t */\n    // adds an new bounds elements to the array and to the DOM\n\n\n    var addBounds = function addBounds() {\n      var v = _ctrl.info(\"vertical\"); // apply stuff we didn't know before...\n\n\n      _util.css(_elemStart.firstChild, {\n        \"border-bottom-width\": v ? 1 : 0,\n        \"border-right-width\": v ? 0 : 1,\n        \"bottom\": v ? -1 : options.indent,\n        \"right\": v ? options.indent : -1,\n        \"padding\": v ? \"0 8px\" : \"2px 4px\"\n      });\n\n      _util.css(_elemEnd, {\n        \"border-top-width\": v ? 1 : 0,\n        \"border-left-width\": v ? 0 : 1,\n        \"top\": v ? \"100%\" : \"\",\n        \"right\": v ? options.indent : \"\",\n        \"bottom\": v ? \"\" : options.indent,\n        \"left\": v ? \"\" : \"100%\",\n        \"padding\": v ? \"0 8px\" : \"2px 4px\"\n      }); // append\n\n\n      _boundsContainer.appendChild(_elemBounds);\n    }; // remove bounds from list and DOM\n\n\n    var removeBounds = function removeBounds() {\n      _elemBounds.parentNode.removeChild(_elemBounds);\n    }; // update the start and end positions of the scene\n\n\n    var updateBounds = function updateBounds() {\n      if (_elemBounds.parentNode !== _boundsContainer) {\n        addBounds(); // Add Bounds elements (start/end)\n      }\n\n      var css = {};\n      css[_vertical ? \"top\" : \"left\"] = Scene.triggerPosition();\n      css[_vertical ? \"height\" : \"width\"] = Scene.duration();\n\n      _util.css(_elemBounds, css);\n\n      _util.css(_elemEnd, {\n        display: Scene.duration() > 0 ? \"\" : \"none\"\n      });\n    };\n    /*\n    \t\t * ----------------------------------------------------------------\n    \t\t * trigger and trigger group management\n    \t\t * ----------------------------------------------------------------\n    \t\t */\n    // adds an new trigger group to the array and to the DOM\n\n\n    var addTriggerGroup = function addTriggerGroup() {\n      var triggerElem = TPL.trigger(options.colorTrigger); // new trigger element\n\n      var css = {};\n      css[_vertical ? \"right\" : \"bottom\"] = 0;\n      css[_vertical ? \"border-top-width\" : \"border-left-width\"] = 1;\n\n      _util.css(triggerElem.firstChild, css);\n\n      _util.css(triggerElem.firstChild.firstChild, {\n        padding: _vertical ? \"0 8px 3px 8px\" : \"3px 4px\"\n      });\n\n      document.body.appendChild(triggerElem); // directly add to body\n\n      var newGroup = {\n        triggerHook: Scene.triggerHook(),\n        element: triggerElem,\n        members: [Indicator]\n      };\n\n      _ctrl._indicators.groups.push(newGroup);\n\n      Indicator.triggerGroup = newGroup; // update right away\n\n      _ctrl._indicators.updateTriggerGroupLabel(newGroup);\n\n      _ctrl._indicators.updateTriggerGroupPositions(newGroup);\n    };\n\n    var removeTriggerGroup = function removeTriggerGroup() {\n      _ctrl._indicators.groups.splice(_ctrl._indicators.groups.indexOf(Indicator.triggerGroup), 1);\n\n      Indicator.triggerGroup.element.parentNode.removeChild(Indicator.triggerGroup.element);\n      Indicator.triggerGroup = undefined;\n    }; // updates the trigger group -> either join existing or add new one\n\n    /*\t\n    \t\t * Logic:\n    \t\t * 1 if a trigger group exist, check if it's in sync with Scene settings â€“ if so, nothing else needs to happen\n    \t\t * 2 try to find an existing one that matches Scene parameters\n    \t\t * \t 2.1 If a match is found check if already assigned to an existing group\n    \t\t *\t\t\t If so:\n    \t\t *       A: it was the last member of existing group -> kill whole group\n    \t\t *       B: the existing group has other members -> just remove from member list\n    \t\t *\t 2.2 Assign to matching group\n    \t\t * 3 if no new match could be found, check if assigned to existing group\n    \t\t *   A: yes, and it's the only member -> just update parameters and positions and keep using this group\n    \t\t *   B: yes but there are other members -> remove from member list and create a new one\n    \t\t *   C: no, so create a new one\n    \t\t */\n\n\n    var updateTriggerGroup = function updateTriggerGroup() {\n      var triggerHook = Scene.triggerHook(),\n          closeEnough = 0.0001; // Have a group, check if it still matches\n\n      if (Indicator.triggerGroup) {\n        if (Math.abs(Indicator.triggerGroup.triggerHook - triggerHook) < closeEnough) {\n          // _util.log(0, \"trigger\", options.name, \"->\", \"no need to change, still in sync\");\n          return; // all good\n        }\n      } // Don't have a group, check if a matching one exists\n      // _util.log(0, \"trigger\", options.name, \"->\", \"out of sync!\");\n\n\n      var groups = _ctrl._indicators.groups,\n          group,\n          i = groups.length;\n\n      while (i--) {\n        group = groups[i];\n\n        if (Math.abs(group.triggerHook - triggerHook) < closeEnough) {\n          // found a match!\n          // _util.log(0, \"trigger\", options.name, \"->\", \"found match\");\n          if (Indicator.triggerGroup) {\n            // do I have an old group that is out of sync?\n            if (Indicator.triggerGroup.members.length === 1) {\n              // is it the only remaining group?\n              // _util.log(0, \"trigger\", options.name, \"->\", \"kill\");\n              // was the last member, remove the whole group\n              removeTriggerGroup();\n            } else {\n              Indicator.triggerGroup.members.splice(Indicator.triggerGroup.members.indexOf(Indicator), 1); // just remove from memberlist of old group\n\n              _ctrl._indicators.updateTriggerGroupLabel(Indicator.triggerGroup);\n\n              _ctrl._indicators.updateTriggerGroupPositions(Indicator.triggerGroup); // _util.log(0, \"trigger\", options.name, \"->\", \"removing from previous member list\");\n\n            }\n          } // join new group\n\n\n          group.members.push(Indicator);\n          Indicator.triggerGroup = group;\n\n          _ctrl._indicators.updateTriggerGroupLabel(group);\n\n          return;\n        }\n      } // at this point I am obviously out of sync and don't match any other group\n\n\n      if (Indicator.triggerGroup) {\n        if (Indicator.triggerGroup.members.length === 1) {\n          // _util.log(0, \"trigger\", options.name, \"->\", \"updating existing\");\n          // out of sync but i'm the only member => just change and update\n          Indicator.triggerGroup.triggerHook = triggerHook;\n\n          _ctrl._indicators.updateTriggerGroupPositions(Indicator.triggerGroup);\n\n          return;\n        } else {\n          // _util.log(0, \"trigger\", options.name, \"->\", \"removing from previous member list\");\n          Indicator.triggerGroup.members.splice(Indicator.triggerGroup.members.indexOf(Indicator), 1); // just remove from memberlist of old group\n\n          _ctrl._indicators.updateTriggerGroupLabel(Indicator.triggerGroup);\n\n          _ctrl._indicators.updateTriggerGroupPositions(Indicator.triggerGroup);\n\n          Indicator.triggerGroup = undefined; // need a brand new group...\n        }\n      } // _util.log(0, \"trigger\", options.name, \"->\", \"add a new one\");\n      // did not find any match, make new trigger group\n\n\n      addTriggerGroup();\n    };\n  };\n  /*\n  \t * ----------------------------------------------------------------\n  \t * Templates for the indicators\n  \t * ----------------------------------------------------------------\n  \t */\n\n\n  var TPL = {\n    start: function start(color) {\n      // inner element (for bottom offset -1, while keeping top position 0)\n      var inner = document.createElement(\"div\");\n      inner.textContent = \"start\";\n\n      _util.css(inner, {\n        position: \"absolute\",\n        overflow: \"visible\",\n        \"border-width\": 0,\n        \"border-style\": \"solid\",\n        color: color,\n        \"border-color\": color\n      });\n\n      var e = document.createElement('div'); // wrapper\n\n      _util.css(e, {\n        position: \"absolute\",\n        overflow: \"visible\",\n        width: 0,\n        height: 0\n      });\n\n      e.appendChild(inner);\n      return e;\n    },\n    end: function end(color) {\n      var e = document.createElement('div');\n      e.textContent = \"end\";\n\n      _util.css(e, {\n        position: \"absolute\",\n        overflow: \"visible\",\n        \"border-width\": 0,\n        \"border-style\": \"solid\",\n        color: color,\n        \"border-color\": color\n      });\n\n      return e;\n    },\n    bounds: function bounds() {\n      var e = document.createElement('div');\n\n      _util.css(e, {\n        position: \"absolute\",\n        overflow: \"visible\",\n        \"white-space\": \"nowrap\",\n        \"pointer-events\": \"none\",\n        \"font-size\": FONT_SIZE\n      });\n\n      e.style.zIndex = ZINDEX;\n      return e;\n    },\n    trigger: function trigger(color) {\n      // inner to be above or below line but keep position\n      var inner = document.createElement('div');\n      inner.textContent = \"trigger\";\n\n      _util.css(inner, {\n        position: \"relative\"\n      }); // inner wrapper for right: 0 and main element has no size\n\n\n      var w = document.createElement('div');\n\n      _util.css(w, {\n        position: \"absolute\",\n        overflow: \"visible\",\n        \"border-width\": 0,\n        \"border-style\": \"solid\",\n        color: color,\n        \"border-color\": color\n      });\n\n      w.appendChild(inner); // wrapper\n\n      var e = document.createElement('div');\n\n      _util.css(e, {\n        position: \"fixed\",\n        overflow: \"visible\",\n        \"white-space\": \"nowrap\",\n        \"pointer-events\": \"none\",\n        \"font-size\": FONT_SIZE\n      });\n\n      e.style.zIndex = ZINDEX;\n      e.appendChild(w);\n      return e;\n    }\n  };\n});\n"],"sourceRoot":""}